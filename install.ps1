<#
.SYNOPSIS
Easily install Minecraft Modpacks.
.Description
Lets users easily install and update Minecraft Modpacks.
Is to be packaged alongside all other Packfiles (i.e. same directory as "mods" or "saves")
Script by Chaos_02/Markus Noack.
.PARAMETER debug
Turns on PowerShell debugging mode and saves to $launcherProfiles.new instead.
.PARAMETER noForge
Script does not try to install latest Forge version.
.PARAMETER noJava
Script does not try to launch bundled Java installer.
Implies -noForge.
.PARAMETER PackName
Specifies the name of the Modpack to use throughout the script.
.PARAMETER defaultDir
Provides the user with a default install directory that gets deleted if unused.
.PARAMETER installDir
Sets the installation directory via argument instead of prompting with dialog.
Overrides -defaultDir.
Default: '$Env:AppData\.minecraft\$PackName'
.PARAMETER JRE
Specifies path to Java Runtime Environment.
Used to launch Forge installer and in Minecraft profile.
Default: 'C:\Program Files (x86)\Common Files\Oracle\Java\javapath'
.PARAMETER $RAMmult
Percentage of how much free system memory Minecraft may use.
Example: User has 16G of memory, 10G free while installing. -RAMmult 90 will set -Xmx9G for Minecraft
.PARAMETER javaArgs
Provide custom java arguments for the Minecraft installation.
Disables automatic RAM allocation by the script!
.PARAMETER launcherProfiles
Specifies .json file to use as input.
Use files generated by Minecraft launcher!
#> 


param(
	[switch]$noForge,
	[switch]$noJava,
	[string]$PackName='TechAttack',
	[parameter(ParameterSetName='InstallDirectory')] [string]$defaultDir="$Env:AppData\.minecraft\$PackName",
	[parameter(ParameterSetName='InstallDirectory')] [string]$installDir,
	[string]$JRE='C:\Program Files (x86)\Common Files\Oracle\Java\javapath',
	[byte]$RAMmult=90,
	[string]$javaArgs,
	[string]$launcherProfiles = "$Env:AppData\.minecraft\launcher_profiles.json"
)
###################TODO##################
#use pwsh (Powershell >7) for cleaner json output.
#
#########################################

if ($DebugPreference) {
	Set-PSDebug -Trace 2
}

# Self-elevate the script if required
		Function Elevate() {
			if (-Not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] 'Administrator')) {
				if ([int](Get-CimInstance -Class Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber) -ge 6000) {
					foreach ( $Key in $MyInvocation.BoundParameters.Keys ) { $argList += '-' + "$Key" }
					$CommandLine = '-File "' + $MyInvocation.MyCommand.Path + '" ' + $argList + $MyInvocation.UnboundArguments
					if ($DebugPreference) {
						Write-Host ($MyInvocation | Format-List | Out-String)
						Write-Host "$CommandLine"
					}
					Start-Process -Wait -FilePath PowerShell.exe -Verb Runas -ArgumentList $CommandLine #$CommandLine
					Set-PSDebug -Off
					exit $LASTEXITCODE
				}
			}
		}

# Folder select GUI
		Function Get-Folder([string]$initialDirectory,[string]$RootFolder) {
	    	[void] [System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms')
	    	$FolderBrowserDialog = New-Object System.Windows.Forms.FolderBrowserDialog
			$FolderBrowserDialog.Description = "Select the install directory"
	    	if ( [string]::IsNullOrWhiteSpace($RootFolder) ) { 
				$FolderBrowserDialog.RootFolder = 'Desktop' # one of
					#Desktop, Programs, MyDocuments, Personal, Favorites, Startup, Recent, SendTo, StartMenu, MyMusic, MyVideos,
					#DesktopDirectory, MyComputer, NetworkShortcuts, Fonts, Templates, CommonStartMenu, CommonPrograms, CommonStartup,
					#CommonDesktopDirectory, ApplicationData, PrinterShortcuts, LocalApplicationData, InternetCache, Cookies, History,
					#CommonApplicationData, Windows, System, ProgramFiles, MyPictures, UserProfile, SystemX86, ProgramFilesX86,
					#CommonProgramFiles, CommonProgramFilesX86, CommonTemplates, CommonDocuments, CommonAdminTools, AdminTools,
					#CommonMusic, CommonPictures, CommonVideos, Resources, LocalizedResources, CommonOemLinks, CDBurning
			} else { $FolderBrowserDialog.RootFolder = $RootFolder }
			if ( !([string]::IsNullOrWhiteSpace($initialDirectory)) ) { 
				$FolderBrowserDialog.SelectedPath = $initialDirectory + "\"
			}
			Write-Host -ForegroundColor Red -BackgroundColor Yellow  "`n`n`t* * * `t`tW A R N I N G :   Dialog box may be hidden behind another [or this] window!!!`t`t* * *`n"
			$Result = $FolderBrowserDialog.ShowDialog((New-Object System.Windows.Forms.Form -Property @{TopMost = $true }))#|Out-Null
	    	if ( $Result -eq [Windows.Forms.DialogResult]::OK -and !([string]::IsNullOrWhiteSpace($Result)) ) {
	    		$Result = $FolderBrowserDialog.SelectedPath
			}
			$FolderBrowserDialog.Dispose()
			return $Result
		}
# Imported from online source yet to be found again :/
		Function Resize-Image{
		    param(
		        [parameter(mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,ParameterSetName='A')][parameter(mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,ParameterSetName='B')][alias("FullName")][string[]]$images,
		        [parameter(mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,ParameterSetName='A')][parameter(mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,ParameterSetName='B')][alias("DirectoryName")][string]$OutPath,
		        [parameter(mandatory=$true,ParameterSetName='A')][parameter(mandatory=$true,ParameterSetName='B')][int32]$NewWidth,
		        [parameter(mandatory=$true,ParameterSetName='A')][parameter(mandatory=$true,ParameterSetName='B')][int32]$NewHeight,
		        [parameter(mandatory=$false,ParameterSetName='A')][switch]$AppendSizeToFilename,
		        [parameter(mandatory=$true,ParameterSetName='B')][switch]$replaceoriginal,
		        [parameter(mandatory=$false)][switch]$DownSizeOnly
		    )
		    begin{
		        Add-Type -AssemblyName System.Drawing
		    }
		    process{
		        $images | %{
		            $rand_name = [IO.Path]::GetRandomFileName()
		            $ext = [System.IO.Path]::GetExtension($_)
		            $basename = [System.IO.Path]::GetFileNameWithoutExtension($_)
		            
		            if ($ext -match "\.(bmp|jpe?g|gif|tiff?|png)$"){
		                Try{
		                    $img = [System.Drawing.Bitmap]::FromFile($_)
		                    $percentWidth = $newWidth / $img.Width
		                    $percentHeight = $newHeight / $img.Height
		                    if ($percentWidth -lt $percentHeight){$ratio = $percentWidth}else{$ratio = $percentHeight}
		                    [int32]$nWidth = $img.Width * $ratio
		                    [int32]$nHeight = $img.Height * $ratio
		                    if ($replaceoriginal.IsPresent -and $ratio -ge 1){
		                        return
		                    }
		                    if($DownSizeOnly.IsPresent -and $ratio -ge 1){
		                        if (!(Test-Path "$outPath\$([System.IO.Path]::GetFileName($_))")){
		                            copy-item $_ $outPath
		                        }
		                        return
		                    }
		                    $newImg = new-Object System.Drawing.Bitmap($nWidth,$nHeight)
		                    ([System.Drawing.Graphics]::FromImage($newImg)).DrawImage($img,0,0,$newImg.Width,$newImg.Height)
		                    $newImagePath = ""
		                    if ($replaceoriginal.IsPresent){
		                        $newImagePath = "$outPath\$([IO.Path]::GetRandomFileName())"
		                        while(Test-Path $newImagePath){
		                            $newImagePath = "$outPath\$([IO.Path]::GetRandomFileName())"
		                        }
		                    }elseif($AppendSizeToFilename.IsPresent){
		                        $newImagePath = "$outPath\$($basename)_$($nWidth)x$($nHeight)$ext"
		                    }else{
		                        $newImagePath = "$outPath\$basename$ext"
		                    }
		                    if(!(test-Path $outPath)){md $outPath}
		                    $newImg.Save($newImagePath,$img.RawFormat)
		                    if ($replaceoriginal.IsPresent){
		                        $img.Dispose()
		                        Remove-Item $_ -Force
		                        Rename-Item $newImagePath -NewName ([System.IO.Path]::GetFileName($_))
		                    }
		                }catch{
		                    Write-Error -Message $_.Exception.Message
		                }finally{
		                    if ($img){$img.Dispose()}
		                    if ($newImg){$newImg.Dispose()}
		                }
		            }else{
		                Write-Error -Message "Das Bild '$_' hat kein unterstütztes Format. Folgende Formate werden unterstützt: bmp|jpg|gif|tif|png"
		            }
		        }
		    
		    }
		    end{
		        if ($img){$img.Dispose()}
		        if ($newImg){$newImg.Dispose()}
		        [System.GC]::Collect()
		    }
		}
		
# Imported from https://github.com/DevAndersen/posh-bucket/blob/master/projects/consoleImageRenderer/consoleImageRenderer.ps1
		#region Parameters
		
		Function Image-Render{
			param(
				[Parameter(Mandatory, ParameterSetName = "Normal")]
				[Parameter(Mandatory, ParameterSetName = "Resize")]
				[Parameter(Mandatory, ParameterSetName = "FillMode")]
				[String]$Path,
				
				[Parameter(Mandatory, ParameterSetName = "FillMode")]
				[ValidateSet("Stretch", "ProportionalWidth", "ProportionalHeight")]
				[String]$FillMode,
				
				[Parameter(Mandatory, ParameterSetName = "Resize")]
				[Int]$Width,
				
				[Parameter(Mandatory, ParameterSetName = "Resize")]
				[Int]$Height
			)
			
			#endregion
			
			#region Functions
			
			function RenderImage([System.Drawing.Image]$Image)
			{
				[Console]::CursorVisible = $false
				for ($y = 0; $y -lt $Image.Height; $y += 2)
				{
					$pixelStrings = for ($x = 0; $x -lt $Image.Width; $x++)
					{
						$f = $Image.GetPixel($x, $y)
						"$escape[38;2;$($f.R);$($f.G);$($f.b)m"
						
						if ($y -lt $Image.Height - 1)
						{
							$b = $Image.GetPixel($x, $y + 1)
							"$escape[48;2;$($b.R);$($b.G);$($b.B)m"
						}
						
						$halfCharString
					}
					[String]::Join('', $pixelStrings + "$escape[0m")
				}
				[Console]::CursorVisible = $true
			}
			
			function ResizeImage([System.Drawing.Image]$Image, $NewWidth, $NewHeight)
			{
				return $img.GetThumbnailImage($NewWidth, $NewHeight, $null, [IntPtr]::Zero)
			}
			
			function LoadImage()
			{
				$urlRegex = "^http[s]?://"
				if ($Path -match $urlRegex)
				{
					$webClient = [System.Net.WebClient]::new()
					$imageStream = [System.IO.MemoryStream]::new($webClient.DownloadData($Path))
					$webClient.Dispose()
				}
				else
				{
					$absolutePath = Resolve-Path $Path
					$imageStream = [System.IO.File]::OpenRead($absolutePath)
				}
				$img = [System.Drawing.Image]::FromStream($imageStream, $false, $false)
				$imageStream.Dispose()
				return $img
			}
			
			#endregion
			
			#region Main flow
			
			[System.Reflection.Assembly]::LoadWithPartialName("System.Drawing") | Out-Null
			
			$escape = [Char]0x1B
			$halfCharString = [Char]0x2580
			
			$img = LoadImage
			
			switch ($PSCmdlet.ParameterSetName)
			{
				"Resize"
				{
					$img = ResizeImage -Image $img -NewWidth $Width -NewHeight $Height
				}
				"FillMode"
				{
					switch ($FillMode)
					{
						"Stretch"
						{
							$w = [Console]::WindowWidth
							$h = [Console]::WindowHeight * 2
						}
						"ProportionalWidth"
						{
							$w = [Console]::WindowWidth
							$h = ($img.Height / $img.Width) * [Console]::WindowWidth
						}
						"ProportionalHeight"
						{
							$w = ($img.Height / $img.Width) * [Console]::WindowHeight * 1.75
							$h = [Console]::WindowHeight * 1.75
						}
					}
					
					$img = ResizeImage -Image $img -NewWidth $w -NewHeight $h
				}
			}
			
			RenderImage -Image $img 
			
			$img.Dispose()
			
			#endregion
		}
		
		Add-Type -AssemblyName Microsoft.VisualBasic
# Imported from online, source yet to be found again :/
		Function Remove-Item-ToRecycleBin($Path) {
		    $item = Get-Item -Path $Path -ErrorAction SilentlyContinue
		    if ($item -eq $null)
		    {
		        Write-Error("'{0}' not found" -f $Path)
		    }
		    else
		    {
		        $fullpath=$item.FullName
		        Write-Verbose ("Moving '{0}' to the Recycle Bin" -f $fullpath)
		        if (Test-Path -Path $fullpath -PathType Container)
		        {
		            [Microsoft.VisualBasic.FileIO.FileSystem]::DeleteDirectory($fullpath,'OnlyErrorDialogs','SendToRecycleBin')
		        }
		        else
		        {
		            [Microsoft.VisualBasic.FileIO.FileSystem]::DeleteFile($fullpath,'OnlyErrorDialogs','SendToRecycleBin')
		        }
		    }
		}
		

#Imported from https://gist.github.com/lalibi/3762289efc5805f8cfcf
		Function Set-WindowState {
    <#
    .LINK
    https://gist.github.com/Nora-Ballard/11240204
    #>

    [CmdletBinding(DefaultParameterSetName = 'InputObject')]
    param(
        [Parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $true)]
        [Object[]] $InputObject,

        [Parameter(Position = 1)]
        [ValidateSet('FORCEMINIMIZE', 'HIDE', 'MAXIMIZE', 'MINIMIZE', 'RESTORE',
                     'SHOW', 'SHOWDEFAULT', 'SHOWMAXIMIZED', 'SHOWMINIMIZED',
                     'SHOWMINNOACTIVE', 'SHOWNA', 'SHOWNOACTIVATE', 'SHOWNORMAL')]
        [string] $State = 'SHOW',
        [switch] $SuppressErrors = $false,
        [switch] $SetForegroundWindow = $false
    )

    Begin {
        $WindowStates = @{
        'FORCEMINIMIZE'         = 11
            'HIDE'              = 0
            'MAXIMIZE'          = 3
            'MINIMIZE'          = 6
            'RESTORE'           = 9
            'SHOW'              = 5
            'SHOWDEFAULT'       = 10
            'SHOWMAXIMIZED'     = 3
            'SHOWMINIMIZED'     = 2
            'SHOWMINNOACTIVE'   = 7
            'SHOWNA'            = 8
            'SHOWNOACTIVATE'    = 4
            'SHOWNORMAL'        = 1
        }

        $Win32ShowWindowAsync = Add-Type -MemberDefinition @'
[DllImport("user32.dll")]
public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);
[DllImport("user32.dll", SetLastError = true)]
public static extern bool SetForegroundWindow(IntPtr hWnd);
'@ -Name "Win32ShowWindowAsync" -Namespace Win32Functions -PassThru

        if (!$global:MainWindowHandles) {
            $global:MainWindowHandles = @{ }
        }
    }

    Process {
        foreach ($process in $InputObject) {
            $handle = $process.MainWindowHandle

            if ($handle -eq 0 -and $global:MainWindowHandles.ContainsKey($process.Id)) {
                $handle = $global:MainWindowHandles[$process.Id]
            }

            if ($handle -eq 0) {
                if (-not $SuppressErrors) {
                    Write-Error "Main Window handle is '0'"
                }
                continue
            }

            $global:MainWindowHandles[$process.Id] = $handle

            $Win32ShowWindowAsync::ShowWindowAsync($handle, $WindowStates[$State]) | Out-Null
            if ($SetForegroundWindow) {
                $Win32ShowWindowAsync::SetForegroundWindow($handle) | Out-Null
            }

            Write-Verbose ("Set Window State '{1} on '{0}'" -f $MainWindowHandle, $State)
        }
    }
}
		
		
try {
	Set-Location -Path "$PSScriptRoot"
	
	
	
	$ScreenInfo = wmic path Win32_VideoController get VideoModeDescription
	$ScreenInfo = $ScreenInfo | Select-String -pattern '\d+' -AllMatches
	#Set-ConsoleSize -Width (($ScreenInfo.Matches[0].Value)/2) -Height $ScreenInfo.Matches[1].Value
	Get-Process powershell | Set-WindowState -State 'MAXIMIZE'
	
	
	Set-PSDebug -Off
	Image-Render -Path "$PSScriptRoot\pack-icon.png" -FillMode ProportionalHeight
	if ($DebugPreference) { Set-PSDebug -Trace 2 }
	
	
	#gets latest forge version
	if (Test-Path "$PSScriptRoot\forge*installer.jar") {
		#$Forge = $(((Gci $PSScriptRoot -filter 'forge*installer.jar' | sort-object name)[-1]).fullname)
		#$Forge -match '[^\\]+$'
		#$Forge = $Matches[0]
		#$Matches.Clear()
	
		#find actual latest Forge file
		Set-PSDebug -Off
		$ForgeUnsorted = @(Gci $PSScriptRoot -filter 'forge*installer.jar' | sort-object name)
		$ForgeCompare = [int[]]::new($ForgeUnsorted.length)
		for ($i=0; $i -lt $ForgeUnsorted.length; $i++) {
			$tmp = (Gci $ForgeUnsorted[$i]).Name | Select-String -pattern '\d+' -AllMatches
			for ($j=0; $j -lt $tmp.Matches.Count; $j++) {
				$ForgeCompare[$i] += $('{0:d2}' -f $tmp.Matches[$j].Value)
			}
		}
		$Forge = $ForgeUnsorted[[Array]::IndexOf($ForgeCompare, [int](($ForgeCompare | Measure-Object -Maximum).Maximum))]
		Remove-Variable -Scope 0 -Name 'tmp','ForgeCompare','ForgeUnsorted','i','j'
		
		$Forge -match '(?<=forge-)\d+(\.\d+)+(?=-.*installer.jar)' *>$Null
		$MineCraftVersion = $Matches[0]
		$Matches.Clear()
		$Forge -match '(?<=forge-\d+(\.\d+)+-)\d+(\.\d+)+(?=-.*installer.jar)' *>$Null
		$ForgeVersion = $Matches[0]
		$Matches.Clear()
		$lastVersionId = $MineCraftVersion + '-forge-' + $ForgeVersion
		Write-Host "Found Forge installer version $lastVersionId"
		if ($DebugPreference) { Set-PSDebug -Trace 2 }
	} else { $lastVersionId = "1.18.1-forge-39.0.19" ; $Forge = 'forge-1.18.1-39.0.19-installer.jar' }
	
	#Rename-Item -Path "C:\Program Files (x86)\Minecraft Launcher\game\JavaCheck.jar" -NewName "JavaCheck.FuckYou.jar"
	#New-Item -Path "C:\Program Files (x86)\Minecraft Launcher\game\JavaCheck.jar" -ItemType File
	#Set-ItemProperty -Path "C:\Program Files (x86)\Minecraft Launcher\game\JavaCheck.jar" -Name IsReadOnly -Value $true
	
	
	Stop-Process -Force -Name 'Minecraft' -ErrorAction 'SilentlyContinue'
	$json = Get-Content $launcherProfiles | ConvertFrom-Json
	if ($? -eq $False) {
		Write-Host "ungültige Minecraft profil datei!!"
		Write-Host "$launcherProfiles"
		Read-Host "Press ENTER to continue..."
		exit 1
	}
	
	if ( !($noJava) -and !(Test-Path "$JRE\java.exe") -or (& "$JRE\java.exe" -d64 -version)) { #checks for 64bit java
		$noForge = $True
		Start-Process -Wait -FilePath (((Gci $PSScriptRoot -filter 'jre*x64.exe' | sort-object name)[-1]).fullname) -Verb Runas | Out-Null
		#& (((Gci $PSScriptRoot -filter 'jre*x64.exe' | sort-object name)[-1]).fullname) | Out-Null
		if ( !( $LASTEXITCODE -eq 0 ) ) {Write-Host "Error while installing java!"; Write-Host "java installation corrupt :/" ; Read-Host "Press ENTER to continue..." ; exit 1}
	}
	
	if ( !($noForge) -and (!([bool]($json.profiles -match 'forge')) -or !($json.profiles.forge.lastVersionId -eq "$lastVersionId")) ) {
		Write-Host "Forge installation outdated. Starting installer!"
		& $JRE\java.exe -jar "$Forge" | Out-Null #waits for forge to exit
		if ( !( $LASTEXITCODE -eq 0 ) ) {Write-Host "Error while installing forge!" ; Read-Host "Press ENTER to continue..." ; exit 1}
		$json = Get-Content $launcherProfiles | ConvertFrom-Json
		#Remove-Item -Recurse -Force "$PSScriptRoot\libraries"
		#cmd /C del /Q /S "$PSScriptRoot\libraries" >nul
		Remove-Item-ToRecycleBin "$PSScriptRoot\libraries" -ErrorAction 'SilentlyContinue'
		Write-Host "Installing Forge server files!"
		& $JRE\java.exe -jar "$Forge" --installServer | Out-Null
		Remove-Item -Recurse -Force "$PSScriptRoot\run.bat","$PSScriptRoot\run.sh"
		Remove-Item-ToRecycleBin "$PSScriptRoot\$Forge.log" -ErrorAction 'SilentlyContinue'
	}
	
	
	$RAM = [int](($RAMmult/100)*((get-ciminstance Win32_OperatingSystem | % FreePhysicalMemory)/1048576)) #80% of free mem
	$UUID = "$PackName" + "v$MineCraftVersion"
	# $javaArgs = "-Xmx" + $RAM + "G -Xms" + 4 + "G -XX:+UseG1GC -Dsun.rmi.dgc.server.gcInterval=2147483646 -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=20 -XX:G1ReservePercent=20 -XX:MaxGCPauseMillis=20 -XX:G1HeapRegionSize=32M"
	if ( [string]::IsNullOrWhiteSpace($javaArgs) ) {
		$javaArgs = "-Xmx" + $RAM + "G -Xms" + 4 + "G -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:G1NewSizePercent=20 -XX:G1ReservePercent=20 -XX:MaxGCPauseMillis=50 -XX:G1HeapRegionSize=32M"
	}
	# Launcher Icon Bitcheezzz
	Resize-Image -AppendSizeToFilename -images "$PSScriptRoot\pack-icon.png" -OutPath "$PSScriptRoot" -NewWidth 128 -NewHeight 128
	if (Test-Path "$PSScriptRoot\pack-icon_128x128.png") {
		$icon = "data:image/png;base64,$([convert]::ToBase64String((get-content $PSScriptRoot\pack-icon_128x128.png -encoding byte)))"
		Remove-Item -Force "$PSScriptRoot\pack-icon_128x128.png"
	} elseif ([bool]($json.profiles -match 'forge')) {
		$icon = $json.profiles.forge.icon
	} else {
		$icon = "Furnace"
	}
	
	$timestamp = Get-Date -Format 'yyyy-MM-ddTHH:mm:ss.000Z'
	
	$Profile = @{
			'created' = '2021-12-14T11:59:10.792Z'
			'gameDir' = "$defaultDir"
			'icon' = "$icon" #base64 encoded image here
			'javaArgs' = "$javaArgs"
			'javaDir' = "$JRE\javaw.exe"
			'lastUsed' = "$timestamp"
			'lastVersionId' = "$lastVersionId"
			'name' = "$PackName"
			'type' = 'custom';
		}
	
	
	if ( !([bool]($json.profiles -match "$UUID")) -or !((Test-Path "$defaultDir") -or (Test-Path "$json.profiles.$UUID.gameDir")) ) { #create profile
		
		Write-Host "[Installing $PackName Modpack...]"
		if ( [bool]($json.profiles -match "$UUID") -and [bool]($json.profiles.$UUID -match "gameDir") ) {
			if ( !(Test-Path $json.profiles.$UUID.gameDir) ) { New-Item $json.profiles.$UUID.gameDir -ItemType Directory | Out-Null } 
			$installDir = $json.profiles.$UUID.gameDir
		} else {
			if ( [string]::IsNullOrWhiteSpace($installDir) ) {
				New-Item "$defaultDir" -ItemType Directory -ErrorAction 'SilentlyContinue'
				$installDir = Get-Folder "$defaultDir" 'Desktop'
			} else { Write-Host "Installing to passed directory ($installDir)" }
		}
		if (([string]::IsNullOrWhiteSpace($installDir)) -or ($installDir -eq 'Cancel')) {
			Remove-Item "$defaultDir"
			Write-Host "Installation abgebrochen."
			Read-Host "Press ENTER to continue..."
			$ReturnCode = 0
			exit 1
		}
		if ( !($installDir -eq $defaultDir) -and !($installDir -eq $json.profiles.$UUID.gameDir)) {
			Remove-Item "$defaultDir"
			if ( !([bool]("$installDir.ToLower()" -match 'tech') -or [bool]("$installDir.ToLower()" -match 'attack')) ) { # make available to outside
				$installDir = "$installDir\$PackName"
			}
		}	
		
		#install modpack
			
		$Profile.gameDir = $installDir
		if ( !([bool]($json.profiles -match "$UUID")) ) { $json.profiles | add-Member -Name $UUID -value $Profile -MemberType NoteProperty } else { $json.profiles.$UUID = $Profile }
		#$json.profiles.$UUID.Remove($(Select-Object $json.profiles.$UUID.'Name')); $json.profiles.$UUID.Remove('----')
		
		if ( !("$PSScriptRoot" -eq "$installDir") ) { #dont try to overwrite files
			Copy-Item -Force -Exclude "$PackName\" "$PSScriptRoot\*" $installDir
			cmd /c "mklink /D /J $installDir\$($Profile.Item('name')) .\saves\$($Profile.Item('name'))"
			
			if ($? -eq $False) {
				Write-Host "Fehler beim kopieren der Dateien."
				exit 1
			}
		} else { Write-Host "Not copying files, only installing profile. Run again to start update process." }
		
	} else {
		
		Write-Host "[Updating $PackName Modpack installation...]"
		#$json.profiles.$UUID.javaArgs = $javaArgs
		#$json.profiles.$UUID.icon = $icon
		#$json.profiles.$UUID.lastVersionId = $lastVersionId
		$json.profiles.$UUID = $Profile
		
		#update modpack
		if ( !($PSScriptRoot -eq $installdir) ) { #dont try to overwrite files
			#move files from current exec dir to previous installation
			$oldDir = $json.profiles.$UUID.gameDir
			Remove-Item -Recurse -Force "$oldDir\mods","$oldDir\config","$oldDir\crash-reports","$oldDir\logs","$oldDir\libraries"
			Copy-Item -Recurse -Force "$PSScriptRoot\mods","$PSScriptRoot\config","$PSScriptRoot\craftpresence","$PSScriptRoot\resourcepacks","$PSScriptRoot\shaderpacks","$PSScriptRoot\saves","$PSScriptRoot\libraries" "$installDir"
			#update server files aswell!
		} else {
			Write-Host "SCRIPT DIR EQUALS INSTALL DIR"
			Write-Host "Not copying files, only updating profile."
			Read-Host "Press ENTER to continue..."
		}
	}
	$json.profiles.$UUID = $json.profiles.$UUID | Sort-Object #alphabetically sorts new profile by property
	if ( !($DebugPreference) ) { $launcherProfiles = "$launcherProfiles" } else { $launcherProfiles = "$launcherProfiles.new" }
	$json | Sort-Object | ConvertTo-Json | Out-File "$launcherProfiles" -Encoding ASCII #https://stackoverflow.com/questions/5596982/using-powershell-to-write-a-file-in-utf-8-without-the-bom
	$ReturnCode = 0
	Write-Host "Finished installation, opening Minecraft!"
	Read-Host "Press ENTER to continue..."
	$MCPKG = Get-AppxPackage | Sort-Object -Property Name | Where { $_.Name -match 'Microsoft.4297127D64EC6' }	# Minecraft Package Name
	if ($DebugPreference) { Set-PSDebug -Step }
	if ( !($MCPKG.Status -eq 'Ok') ) {
		Write-Host -ForegroundColor Red -BackgroundColor Yellow "`n`n`t* * * `t`tINSTALL MINECRAFT LAUNCHER FROM WINDOWS STORE`t`t* * *"
		Start-Process "ms-windows-store://pdp/?ProductId=9PGW18NPBZV5"
		do {
			$MCPKG = Get-AppxPackage | Sort-Object -Property Name | Where { $_.Name -match 'Microsoft.4297127D64EC6' }
			Start-Sleep -Seconds 5
		} until ( $MCPKG.Status -eq 'Ok' )
		Stop-Process -Force -Name 'WinStore.App.exe' -ErrorAction 'SilentlyContinue'
		#Stop-Process -Force -Name 'XboxPcApp.exe' | Out-Null
	}
	Start-Process -FilePath ($MCPKG.InstallLocation + "\Minecraft.exe")
} finally { #capture sigint
	Set-PSDebug -Off
	if ( !($ReturnCode -eq 0) ) {
		Write-Host "STOPPED INSTALLATION"
		Read-Host "Press ENTER to continue..."
		exit 1
	} else { exit 0 }
}
